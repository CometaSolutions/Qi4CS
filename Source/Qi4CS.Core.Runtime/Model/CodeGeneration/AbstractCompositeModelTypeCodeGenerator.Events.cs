/*
 * Copyright 2012 Stanislav Muhametsin. All rights Reserved.
 *
 * Licensed  under the  Apache License,  Version 2.0  (the "License");
 * you may not use  this file  except in  compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed  under the  License is distributed on an "AS IS" BASIS,
 * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or
 * implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 */
#if QI4CS_SDK
using System;
using System.Linq;
using CILAssemblyManipulator.API;
using Qi4CS.Core.API.Common;
using Qi4CS.Core.API.Instance;
using Qi4CS.Core.API.Model;
using Qi4CS.Core.SPI.Model;

namespace Qi4CS.Core.Runtime.Model
{
   public abstract partial class AbstractCompositeModelTypeCodeGenerator
   {
      protected const String EVENT_METHOD_PREFIX = "Event";
      protected const String EVENT_ADDITION_POSTFIX = "Add";
      protected const String EVENT_REMOVAL_POSTFIX = "Remove";
      protected const String EVENT_INVOCATION_POSTFIX = "Invoke";
      protected const String EVENT_CLEAR_POSTFIX = "Clear";
      protected const String EVENT_CHECKER_POSTFIX = "Checker";
      protected const String EVENT_FIELD_PREFIX = "_event";

      protected void EmitEventRelatedThings(
         CompositeTypeGenerationInfo thisGenerationInfo,
         CompositeMethodGenerationInfo thisMethodGenerationInfo,
         EventModel eventModel,
         Type genericEventMixinType
      )
      {
         var nEventInfo = eventModel.NativeInfo;
         var eventInfo = nEventInfo.NewWrapper( this.ctx );
         CompositeMethodGenerationInfo invokeMethod = null;
         if ( this.IsCompositeGeneratedEvent( thisGenerationInfo, eventModel, genericEventMixinType ) )
         {
            var eventIdx = thisGenerationInfo.AutoGeneratedEventInfos.Count;
            var eventType = TypeGenerationUtils.CreateTypeForEmitting( eventInfo.EventHandlerType, thisGenerationInfo.GenericArguments, null );
            var invokeMethodFromModel = eventModel.NativeInfo.EventHandlerType.GetMethod( DELEGATE_INVOKE_METHOD_NAME ).NewWrapper( this.ctx );

            CILTypeBase fieldType;
            Action<CILField, MethodIL> addAction, removeAction;
            Action<EventModel, CompositeTypeGenerationInfo, CILField, CILTypeBase, CompositeMethodGenerationInfo, CILMethod> invokeAction;
            Action<CILField, MethodIL> checkAction;
            this.CreateEmittingActionsForEvent(
               eventModel,
               eventType,
               out fieldType,
               out addAction,
               out removeAction,
               out invokeAction,
               out checkAction
               );

            // Field:
            // private <field type> _event<idx>;
            var eventField = thisGenerationInfo.Builder.AddField(
               EVENT_FIELD_PREFIX + eventIdx,
               fieldType,
               FieldAttributes.Private
               );

            var addMethod = this.ImplementMethodForEmitting(
               thisGenerationInfo,
               eventModel.AddMethod.NativeInfo.NewWrapper( this.ctx ),
               EVENT_METHOD_PREFIX + eventIdx + EVENT_ADDITION_POSTFIX,
               MethodAttributes.Private | MethodAttributes.HideBySig,
               false
               );
            this.EmitThrowIfApplicationNotActiveWithoutLocalVariable( thisGenerationInfo, addMethod.IL );
            addAction( eventField, addMethod.IL );

            CompositeMethodGenerationInfo removeMethod = this.ImplementMethodForEmitting(
               thisGenerationInfo,
               eventModel.RemoveMethod.NativeInfo.NewWrapper( this.ctx ),
               EVENT_METHOD_PREFIX + eventIdx + EVENT_REMOVAL_POSTFIX,
               MethodAttributes.Private | MethodAttributes.HideBySig,
               false
               );
            this.EmitThrowIfApplicationNotActiveWithoutLocalVariable( thisGenerationInfo, removeMethod.IL );
            removeAction( eventField, removeMethod.IL );

            invokeMethod = this.ImplementMethodForEmitting(
               thisGenerationInfo,
               decType => TypeGenerationUtils.CreateTypeForEmittingCILType( decType, thisGenerationInfo.GenericArguments, null ),
               invokeMethodFromModel,
               EVENT_METHOD_PREFIX + eventIdx + EVENT_INVOCATION_POSTFIX,
               MethodAttributes.Private | MethodAttributes.HideBySig,
               false );
            var eventMethodToInvoke = invokeMethod.OverriddenMethod;
            this.EmitThrowIfApplicationNotActiveWithoutLocalVariable( thisGenerationInfo, invokeMethod.IL );
            invokeAction( eventModel, thisGenerationInfo, eventField, eventType, invokeMethod, eventMethodToInvoke );

            // Field clearer method:
            // private void Event<idx>Clear()
            // {
            //   Interlocked.Exchange<TEvent>(ref this._event<idx>, null);
            // }
            var eventClearMB = thisGenerationInfo.Builder.AddMethod(
               EVENT_METHOD_PREFIX + eventIdx + EVENT_CLEAR_POSTFIX,
               MethodAttributes.Private | MethodAttributes.HideBySig,
               CallingConventions.HasThis );
            var il = eventClearMB.MethodIL;


            this.EmitThrowIfApplicationNotActiveWithoutLocalVariable( thisGenerationInfo, il );

            il.EmitLoadThisFieldAddress( eventField );
            il.EmitLoadNull();
            il.EmitCall( INTERLOCKED_EXCHANGE_METHOD_GDEF.MakeGenericMethod( fieldType ) );
            il.EmitPop();
            il.EmitReturn();

            // Field checker method:
            // private Boolean Event<idx>Checker()
            // {
            //   // for strong refs
            //   return this._event<idx>;
            //   // for weak refs
            //   return 
            // }
            var eventCheckerMB = thisGenerationInfo.Builder.AddMethod(
               EVENT_METHOD_PREFIX + eventIdx + EVENT_CHECKER_POSTFIX,
               MethodAttributes.Private | MethodAttributes.HideBySig,
               CallingConventions.HasThis
               );
            eventCheckerMB.ReturnParameter.ParameterType = BOOLEAN_TYPE;
            il = eventCheckerMB.MethodIL;

            this.EmitThrowIfApplicationNotActiveWithoutLocalVariable( thisGenerationInfo, il );
            checkAction( eventField, il );

            thisGenerationInfo.AutoGeneratedEventInfos.Add(
               nEventInfo,
               new EventGenerationInfo(
                  this.EmitRefMethodForPropertyOrEvent( eventField, EVENT_METHOD_PREFIX + eventIdx + REF_INVOKER_METHOD_SUFFIX ),
                  eventModel,
                  eventType,
                  eventField,
                  addMethod.Builder,
                  removeMethod.Builder,
                  invokeMethod.Builder,
                  eventClearMB,
                  eventCheckerMB
                  )
               );

         }

         if ( this.NeedToEmitAdditionalMemberInfo( thisGenerationInfo, eventInfo.Name, ( parent, name ) => parent.DeclaredEvents.FirstOrDefault( evt => Object.Equals( evt.Name, name ) ) ) )
         {
            // Need to define event if we inherit property directly from interface
            var name = eventInfo.Name;
            if ( thisGenerationInfo.RawEventInfos.Keys.Any( pInfo => pInfo.Name.Equals( name ) ) )
            {
               // We already have event with the same name from different type
               name = QualifiedName.FromMemberInfo( nEventInfo ).ToString();
            }

            CILEvent eBuilder;
            if ( !thisGenerationInfo.RawEventInfos.TryGetValue( nEventInfo, out eBuilder ) )
            {
               eBuilder = thisGenerationInfo.Builder.AddEvent(
                  name,
                  eventInfo.Attributes,
                  TypeGenerationUtils.CreateTypeForEmitting( eventInfo.EventHandlerType, thisGenerationInfo.GenericArguments, null )
                  );
               if ( invokeMethod != null )
               {
                  eBuilder.RaiseMethod = invokeMethod.Builder;
               }
               thisGenerationInfo.RawEventInfos.Add( nEventInfo, eBuilder );
            }

            if ( thisMethodGenerationInfo.MethodFromModel.Equals( eventInfo.AddMethod ) )
            {
               eBuilder.AddMethod = thisMethodGenerationInfo.Builder;
            }
            else if ( thisMethodGenerationInfo.MethodFromModel.Equals( eventInfo.RemoveMethod ) )
            {
               eBuilder.RemoveMethod = thisMethodGenerationInfo.Builder;
            }
            else
            {
               throw new InternalException( "Found an event, but neither adder nor remover methods matched the method being emitted. Event is " + eventInfo + ", method is " + thisMethodGenerationInfo.MethodFromModel + "." );
            }
         }
      }

      protected Boolean IsCompositeGeneratedEvent(
         CompositeTypeGenerationInfo thisGenerationInfo,
         EventModel eventModel,
         Type genericEventMixinType
         )
      {
         return !thisGenerationInfo.AutoGeneratedEventInfos.ContainsKey( eventModel.NativeInfo ) &&
            eventModel.AddMethod != null &&
            eventModel.RemoveMethod != null &&
            genericEventMixinType.Equals( eventModel.AddMethod.Mixin.NativeInfo.DeclaringType ) &&
            genericEventMixinType.Equals( eventModel.RemoveMethod.Mixin.NativeInfo.DeclaringType );
      }

      protected void CreateEmittingActionsForEvent(
         EventModel eventModel,
         CILTypeBase eventType,
         out CILTypeBase fieldType,
         out Action<CILField, MethodIL> addAction,
         out Action<CILField, MethodIL> removeAction,
         out Action<EventModel, CompositeTypeGenerationInfo, CILField, CILTypeBase, CompositeMethodGenerationInfo, CILMethod> invokeAction,
         out Action<CILField, MethodIL> checkAction
         )
      {
         //var storage = eventModel.GetEventStorageKind();

         //if ( EventStorage.STRONG_REFS.Equals( storage ) )
         //{
         fieldType = eventType;
         addAction = ( eventField, il ) => this.EmitEventModificationMethodForStronglyReferencedEvents( eventField, il, DELEGATE_COMBINE_METHOD );
         removeAction = ( eventField, il ) => this.EmitEventModificationMethodForStronglyReferencedEvents( eventField, il, DELEGATE_REMOVE_METHOD );
         invokeAction = this.EmitEventInvocationMethodForStronglyReferencedEvents;
         checkAction = this.EmitEventCheckMethodForStronglyReferencedEvents;
         //}
         //else
         //{
         //   fieldType = WEAK_EVENT_WRAPPER_TYPE;
         //   addAction = this.EmitEventAdditionMethodForWeaklyReferencedEvents;
         //   removeAction = this.EmitEventRemovingMethodForWeaklyReferencedEvents;
         //   invokeAction = this.EmitEventInvocationMethodForWeaklyReferencedEvents;
         //   checkAction = this.EmitEventCheckMethodForWeaklyReferencedEvents;
         //}
      }

      protected void EmitEventCheckMethodForStronglyReferencedEvents(
         CILField eventField,
         MethodIL il
         )
      {
         il.EmitLoadThisField( eventField )
           .EmitLoadNull()
           .EmitCeq()
           .EmitLoadInt32( 0 )
           .EmitCeq()
           .EmitReturn();
      }

      //protected void EmitEventCheckMethodForWeaklyReferencedEvents(
      //   CILField eventField,
      //   MethodIL il
      //   )
      //{
      //   il.EmitLoadThisField( eventField )
      //     .EmitCall( WEAK_EVENT_ARRAY_CLEANUP_METHOD )
      //     .EmitLoadNull()
      //     .EmitCeq()
      //     .EmitLoadInt32( 0 )
      //     .EmitCeq()
      //     .EmitReturn();
      //}

      protected void EmitEventInvocationMethodForStronglyReferencedEvents(
         EventModel eventModel,
         CompositeTypeGenerationInfo thisGenerationInfo,
         CILField eventField,
         CILTypeBase eventType,
         CompositeMethodGenerationInfo invokeMethod,
         CILMethod eventMethodToInvoke
         )
      {
         this.EmitEventInvocationMethodCore(
            eventModel,
            thisGenerationInfo,
            eventField,
            eventType,
            invokeMethod,
            eventMethodToInvoke,
            ( eventLB, invocationStyle, exceptionType ) =>
            {
               if ( EventInvocation.INVOKE_DIRECTLY.Equals( invocationStyle ) )
               {
                  // Invocation method:
                  // private <return-type> Event<idx>Invoke(<args>)
                  // {
                  //    <event-type> evt = this._event<idx>;
                  //    if (evt != null)
                  //    {
                  //       (return) this._event<idx>(<args>);
                  //    } else <if has return type other than void>
                  //    {
                  //       throw new InvalidOperationException("The event " + <event name> + " is not set.");
                  //    }
                  // }
                  this.EmitEventInvocationWithTryCatchIfNeeded(
                     invocationStyle,
                     exceptionType,
                     invokeMethod,
                     eventMethodToInvoke,
                     il => il.EmitLoadLocal( eventLB ),
                     false
                  );
               }
               else
               {
                  var il = invokeMethod.IL;
                  //  foreach ( Delegate handler in evt.GetInvocationList() )
                  //  {
                  //    try
                  //    {
                  //       result = handler(<args>);
                  //    }
                  //    catch ( Exception exc )
                  //    {
                  //      if ( exceptions == null )
                  //      {
                  //         exceptions = new LinkedList<Exception>();
                  //      }
                  //      exceptions.AddLast( exc );
                  //    }
                  //  }
                  var handlersB = invokeMethod.GetOrCreateLocal( LB_EVENT_HANDLERS );
                  il
                     .EmitLoadLocal( eventLB )
                     .EmitCall( GET_INVOCATION_LIST_METHOD )
                     .EmitStoreLocal( handlersB )

                     .EmitSimpleForLoop(
                     il2 =>
                     {
                        // Int32 index = 0;
                        var idxB = invokeMethod.GetOrCreateLocal( LB_INDEX );
                        il2
                           .EmitLoadInt32( 0 )
                           .EmitStoreLocal( idxB );
                        return idxB;
                     },
                     ( il2, idxB, loopBodyStartLabel ) =>
                     {
                        // index < list.Length
                        il2
                           .EmitLoadLocal( idxB )
                           .EmitLoadLocal( handlersB )
                           .EmitLoadArrayLength()
                           .EmitNumericConversion( CILTypeCode.UInt32, CILTypeCode.Int32, false )
                           .EmitBranch( BranchType.IF_FIRST_LESSER_THAN_SECOND, loopBodyStartLabel );
                     },
                     E_MethodIL.EmitLeftPlusPlus,
                     ( il2, idxB ) =>
                     {
                        this.EmitEventInvocationWithTryCatchIfNeeded(
                           invocationStyle,
                           exceptionType,
                           invokeMethod,
                           eventMethodToInvoke,
                           il3 =>
                           {
                              il3
                                 .EmitLoadLocal( handlersB )
                                 .EmitLoadLocal( idxB )
                                 .EmitLoadElement( handlersB.LocalType )
                                 .EmitCastToType( handlersB.LocalType.GetElementType(), eventType );
                           },
                           true
                           );
                     }
                     );
               }
            } );
      }

      protected void EmitEventInvocationWithTryCatchIfNeeded(
         EventInvocation invocationStyle,
         Type exceptionType,
         CompositeMethodGenerationInfo invokeMethod,
         CILMethod eventMethodToInvoke,
         Action<MethodIL> loadEventAction,
         Boolean storeResult
         )
      {
         invokeMethod.IL.EmitTryCatch(
         EXCEPTION_TYPE,
         il2 =>
         {
            loadEventAction( il2 );
            for ( Int32 idx = 0; idx < invokeMethod.Parameters.Count; ++idx )
            {
               il2.EmitLoadArg( invokeMethod.Parameters[idx].Position + 1 );
            }
            il2.EmitCall( eventMethodToInvoke );
            if ( storeResult && !VOID_TYPE.Equals( eventMethodToInvoke.GetReturnType() ) )
            {
               var resultB = invokeMethod.GetOrCreateLocal( LB_RESULT, invokeMethod.ReturnType );
               il2.EmitStoreLocal( resultB );
            }
         },
         EventInvocation.INVOKE_DIRECTLY.Equals( invocationStyle ) ? (Action<MethodIL>) null : il2 =>
         {
            if ( exceptionType != null )
            {
               this.EmitStoreExceptionListWithinCatch( invokeMethod );
            }
            else
            {
               throw new InternalException( "Non-direct event invocation style, but no exception type specified." );
            }
         },
         false
         );
      }

      protected void EmitStoreExceptionListWithinCatch(
         CompositeMethodGenerationInfo methodGenInfo
         )
      {
         var il = methodGenInfo.IL;
         var exceptionB = methodGenInfo.GetOrCreateLocal( LB_EXCEPTION );
         il.EmitStoreLocal( exceptionB );

         var exceptionListB = methodGenInfo.GetOrCreateLocal( LB_EXCEPTION_LIST );
         var exceptionsOKLabel = il.DefineLabel();
         il
            .EmitLoadLocal( exceptionListB )
            .EmitBranch( BranchType.IF_TRUE, exceptionsOKLabel )
            .EmitNewObject( EXCEPTION_LIST_CTOR )
            .EmitStoreLocal( exceptionListB )
            .MarkLabel( exceptionsOKLabel )
            .EmitLoadLocal( exceptionListB )
            .EmitLoadLocal( exceptionB )
            .EmitCall( ADD_LAST_METHOD.ChangeDeclaringType( ( (CILType) exceptionListB.LocalType ).GenericArguments.ToArray() ) );
      }

      protected void EmitEventInvocationMethodCore(
         EventModel eventModel,
         CompositeTypeGenerationInfo thisGenerationInfo,
         CILField eventField,
         CILTypeBase fieldType,
         CompositeMethodGenerationInfo invokeMethod,
         CILMethod eventMethodToInvoke,
         Action<LocalBuilder, EventInvocation, Type> actualEventInvoking
         )
      {
         var eventInfo = eventModel.NativeInfo;
         var il = invokeMethod.IL;

         var eventLB = il.DeclareLocal( fieldType );
         var afterNullCheckLabel = il.DefineLabel();
         il
            .EmitLoadThisField( eventField )
            .EmitStoreLocal( eventLB )
            .EmitLoadLocal( eventLB )
            .EmitBranch( BranchType.IF_FALSE, afterNullCheckLabel );

         EventInvocation invocationStyle;
         Type exceptionType;
         this.GetEventInvocationStyle( eventModel, out invocationStyle, out exceptionType );

         actualEventInvoking( eventLB, invocationStyle, exceptionType );

         // Throw exception if needed
         if ( EventInvocation.INVOKE_ALL.Equals( invocationStyle ) )
         {
            // TODO TODO TODO 
            this.EmitThrowIfExceptionListHasAny( invokeMethod, exceptionType.GetConstructor( EXCEPTION_ENUMERABLE_ARRAY ).NewWrapper( this.ctx ) );
         }

         if ( !VOID_TYPE.Equals( eventMethodToInvoke.GetReturnType() ) )
         {
            //LocalBuilder amountOfDeadB;
            //if ( invokeMethod.TryGetLocal( LB_AMOUNT_OF_DEAD_EVENT_INFOS, out amountOfDeadB ) )
            //{
            //   il
            //      .EmitLoadLocal( amountOfDeadB )
            //      .EmitBranch( BranchType.IF_FALSE, afterNullCheckLabel );
            //}
            LocalBuilder resultB;
            if ( invokeMethod.TryGetLocal( LB_RESULT, out resultB ) )
            {
               il.EmitLoadLocal( resultB );
            }
            var returnLabel = il.DefineLabel();
            il
               .EmitBranch( BranchType.ALWAYS, returnLabel )
               .MarkLabel( afterNullCheckLabel )
               .EmitLoadString( "The event " + eventInfo.Name + " in " )
               .EmitReflectionObjectOf( TypeGenerationUtils.CreateTypeForEmitting( eventInfo.DeclaringType.NewWrapper( this.ctx ), thisGenerationInfo.GenericArguments, null ) )
               .EmitCall( TO_STRING_METHOD )
               .EmitLoadString( " is not set." )
               .EmitCall( STRING_CONCAT_METHOD_3 )
               .EmitThrowNewException( INVALID_OPERATION_EXCEPTION_CTOR_WITH_STRING )
               .MarkLabel( returnLabel );
         }
         else
         {
            il.MarkLabel( afterNullCheckLabel );
         }

         il.EmitReturn();
      }

      protected void EmitThrowIfExceptionListHasAny( CompositeMethodGenerationInfo methodGenInfo, CILConstructor exceptionCtor )
      {
         var exceptionListB = methodGenInfo.GetLocalOrThrow( LB_EXCEPTION_LIST );
         var il = methodGenInfo.IL;
         var noThrowLabel = il.DefineLabel();
         il
            .EmitLoadLocal( exceptionListB )
            .EmitBranch( BranchType.IF_FALSE, noThrowLabel )
            .EmitLoadLocal( exceptionListB )
            .EmitThrowNewException( exceptionCtor )
            .MarkLabel( noThrowLabel );
      }

      protected void EmitEventModificationMethodForStronglyReferencedEvents(
         CILField eventField,
         MethodIL il,
         CILMethod modificationMethod
         )
      {
         // Code for modifying events:
         // public void Event<idx>Add/Remove( <event type> evt )
         // {
         //    <event type> current = this.<event field>;
         //    <event type> oldCurrent, combined;
         //    do
         //    {
         //       oldCurrent = current;
         //       combined = (EventHandler<EventArgs>) Delegate.Combine( oldCurrent, evt ); <- or Delegate.Remove in case of removal
         //       current = Interlocked.CompareExchange( ref this.<event field>, combined, oldCurrent );
         //    } while ( !Object.ReferenceEquals( current, oldCurrent ) ); <- replace ReferenceEquals with OpCodes.bne.un.s.
         // }
         il.EmitInterlockedCompareExchangeFieldSettingLoop(
            eventField,
            ( il2, oldCurrentB ) => il2
               .EmitLoadLocal( oldCurrentB )
               .EmitLoadArg( 1 )
               .EmitCall( modificationMethod )
               .EmitCastToType( modificationMethod.GetReturnType(), eventField.FieldType )
            )
            .EmitReturn();
      }

      //protected void EmitEventInvocationMethodForWeaklyReferencedEvents(
      //   EventModel eventModel,
      //   CompositeTypeGenerationInfo thisGenerationInfo,
      //   CILField eventField,
      //   CILTypeBase eventType,
      //   CompositeMethodGenerationInfo invokeMethod,
      //   CILMethod eventMethodToInvoke
      //   )
      //{
      //   //   EventHandlerInfoArrayWrapper wrapper = this._myEventManualWeak;
      //   //   if ( wrapper != null )
      //   //   {
      //   //      EventHandlerInfo[] evts = wrapper.Array;
      //   //      Boolean cleanUp = false;
      //   //      try
      //   //      {
      //   //      for ( Int32 idx = 0; idx < wrapper.ElementCount; ++idx )
      //   //      {
      //   //         EventHandlerInfo info = evts[idx];
      //   //         Object target = info.Target;
      //   //         if ( EventHandlerInfoArrayWrapper.IsDead( info ) )
      //   //         {
      //   //            cleanUp = true;
      //   //         }
      //   //         else
      //   //         {
      //   //            (result) = new <event type>(target, info.Method).Invoke(params);
      //   //         }
      //   //      }
      //   //      
      //   //      }
      //   //      finally
      //   //      {
      //   //      if ( cleanUp )
      //   //      {
      //   //         Interlocked.CompareExchange( ref this._myEventManualWeak, EventHandlerInfoArrayWrapper.CleanUp( wrapper ), wrapper );
      //   //      }
      //   //      }
      //   //   }

      //   this.EmitEventInvocationMethodCore(
      //      eventModel,
      //      thisGenerationInfo,
      //      eventField,
      //      WEAK_EVENT_WRAPPER_TYPE,
      //      invokeMethod,
      //      eventMethodToInvoke,
      //      ( eventLB, invocationStyle, exceptionType ) =>
      //      {
      //         var il = invokeMethod.IL;

      //         //      EventHandlerInfo[] evts = wrapper.Array;
      //         var evtsArrayB = il.DeclareLocal( WEAK_EVENT_ARRAY_WRAPPER_ARRAY_GETTER.GetReturnType() );
      //         il
      //            .EmitLoadLocal( eventLB )
      //            .EmitCall( WEAK_EVENT_ARRAY_WRAPPER_ARRAY_GETTER )
      //            .EmitStoreLocal( evtsArrayB );

      //         //      Boolean cleanUp = false;
      //         var cleanUpB = il.DeclareLocal( BOOLEAN_TYPE );
      //         il
      //            .EmitLoadBoolean( false )
      //            .EmitStoreLocal( cleanUpB );

      //         Boolean countingDead = !VOID_TYPE.Equals( invokeMethod.ReturnType );
      //         // Int32 amountOfDead = wrapper.ElementCount;
      //         LocalBuilder amountOfDeadB = null;
      //         if ( countingDead )
      //         {
      //            amountOfDeadB = invokeMethod.GetOrCreateLocal( LB_AMOUNT_OF_DEAD_EVENT_INFOS );
      //            il
      //               .EmitLoadLocal( eventLB )
      //               .EmitCall( WEAK_EVENT_ARRAY_WRAPPER_COUNT_GETTER )
      //               .EmitStoreLocal( amountOfDeadB );
      //         }

      //         il.EmitTryFinally(
      //            il2 => il2.EmitSimpleForLoop(
      //               il3 =>
      //               {
      //                  // Int32 idx = 0
      //                  var idxB = invokeMethod.GetOrCreateLocal( LB_INDEX );
      //                  il3
      //                     .EmitLoadInt32( 0 )
      //                     .EmitStoreLocal( idxB );
      //                  return idxB;
      //               },
      //               ( il3, idxB, loopBodyStartLabel ) =>
      //               {
      //                  // idx < wrapper.ElementCount
      //                  il3
      //                     .EmitLoadLocal( idxB )
      //                     .EmitLoadLocal( eventLB )
      //                     .EmitCall( WEAK_EVENT_ARRAY_WRAPPER_COUNT_GETTER )
      //                     .EmitBranch( BranchType.IF_FIRST_LESSER_THAN_SECOND, loopBodyStartLabel );
      //               },
      //               E_MethodIL.EmitLeftPlusPlus,
      //               ( il3, idxB ) =>
      //               {
      //                  var infoB = il3.DeclareLocal( evtsArrayB.LocalType.GetElementType() );

      //                  //         EventHandlerInfo info = evts[idx];
      //                  il3
      //                     .EmitLoadLocal( evtsArrayB )
      //                     .EmitLoadLocal( idxB )
      //                     .EmitLoadElement( evtsArrayB.LocalType )
      //                     .EmitStoreLocal( infoB );

      //                  //         Object target = info.Target;
      //                  var targetB = il3.DeclareLocal( EVENT_INFO_TARGET_GETTER.GetReturnType() );
      //                  il3
      //                     .EmitLoadLocal( infoB )
      //                     .EmitCall( EVENT_INFO_TARGET_GETTER )
      //                     .EmitStoreLocal( targetB );

      //                  il3.EmitIfElse(
      //                     ( il4, elseLabel, endIfLabel ) =>
      //                     {
      //                        il4
      //                           .EmitLoadLocal( infoB )
      //                           // TODO write out is dead -method
      //                           .EmitCall( IS_EVENT_INFO_DEAD_METHOD )
      //                           .EmitBranch( BranchType.IF_TRUE, elseLabel );
      //                     },
      //                     ( il4, elseLabel, endIfLabel ) =>
      //                     {
      //                        // (result) = new <event type>(target, info.Method).Invoke(params);

      //                        // TODO TODO TODO
      //                        // Consider changing info.Method into returning MethodInfo object, and then
      //                        // use info.Method.Invoke(target, params).
      //                        // Slower, but works with .NET 4 portable and PEVerifier won't give errors/warnings.
      //                        this.EmitEventInvocationWithTryCatchIfNeeded(
      //                           invocationStyle,
      //                           exceptionType,
      //                           invokeMethod,
      //                           eventMethodToInvoke,
      //                           il5 =>
      //                           {
      //                              il5
      //                                 .EmitLoadLocal( targetB )

      //                                 .EmitLoadLocal( infoB )
      //                                 .EmitCall( EVENT_INFO_METHOD_GETTER )
      //                                 .EmitNewObject( TypeGenerationUtils.GetMethodForEmitting( decType => TypeGenerationUtils.CreateTypeForEmittingCILType( decType, thisGenerationInfo.GenericArguments, null ), eventModel.NativeInfo.EventHandlerType.LoadConstructorOrThrow( 2 ).NewWrapper( this.ctx ) ) );
      //                           },
      //                           true
      //                           );
      //                     },
      //                     ( il4, endIfLabel ) =>
      //                     {
      //                        // cleanUp = true;
      //                        il4
      //                           .EmitLoadBoolean( true )
      //                           .EmitStoreLocal( cleanUpB );

      //                        if ( amountOfDeadB != null )
      //                        {
      //                           // --amountOfDead
      //                           il4.EmitLeftMinusMinus( amountOfDeadB );
      //                        }
      //                     }
      //                     );
      //               }
      //            ),
      //            il2 =>
      //               //      if ( cleanUp )
      //               //      {
      //               //         Interlocked.CompareExchange( ref this._myEventManualWeak, EventHandlerInfoArrayWrapper.CleanUp( wrapper ), wrapper );
      //               //      }
      //               il2.EmitIf(
      //               ( il3, endIfLabel ) =>
      //               {
      //                  il3
      //                     .EmitLoadLocal( cleanUpB )
      //                     .EmitBranch( BranchType.IF_FALSE, endIfLabel );
      //               },
      //               ( il3, endIfLabel ) =>
      //               {
      //                  il3
      //                     .EmitLoadThisFieldAddress( eventField )

      //                     .EmitLoadLocal( eventLB )
      //                     .EmitCall( WEAK_EVENT_ARRAY_CLEANUP_METHOD )

      //                     .EmitLoadLocal( eventLB )

      //                     .EmitCall( INTERLOCKED_COMPARE_EXCHANGE_METHOD_GDEF.MakeGenericMethod( eventLB.LocalType ) )
      //                     .EmitPop();
      //               }
      //            ) );
      //      } );
      //}

      //protected void EmitEventAdditionMethodForWeaklyReferencedEvents(
      //   CILField eventField,
      //   MethodIL il
      //   )
      //{
      //   //Delegate[] invocations = <arg-1>.GetInvocationList();
      //   //EventHandlerInfo[] evtsToAdd = new EventHandlerInfo[invocations.Length];
      //   //for ( Int32 i = 0; i < invocations.Length; ++i )
      //   //{
      //   //   evtsToAdd[i] = new EventHandlerInfo( invocations[i] );
      //   //}

      //   //EventHandlerInfoArrayWrapper current = this._myEventManualWeak;
      //   //EventHandlerInfoArrayWrapper oldCurrent, combined;
      //   //do
      //   //{
      //   //   oldCurrent = EventHandlerInfoArrayWrapper.CleanUp( current );
      //   //   combined = EventHandlerInfoArrayWrapper.Combine( oldCurrent, evtsToAdd );
      //   //   current = Interlocked.CompareExchange( ref this._myEventManualWeak, combined, oldCurrent );
      //   //} while ( !Object.ReferenceEquals( current, oldCurrent ) );

      //   var invocationsB = il.DeclareLocal( GET_INVOCATION_LIST_METHOD.GetReturnType() );
      //   il
      //      .EmitLoadArg( 1 )
      //      .EmitCall( GET_INVOCATION_LIST_METHOD )
      //      .EmitStoreLocal( invocationsB );

      //   var evtsToAddB = il.DeclareLocal( STRONG_EVENT_WRAPPER_TYPE.MakeArrayType() );
      //   il
      //      .EmitLoadLocal( invocationsB )
      //      .EmitLoadArrayLength()
      //      .EmitNewArray( evtsToAddB.LocalType.GetElementType() )
      //      .EmitStoreLocal( evtsToAddB )

      //      .EmitSimpleForLoop(
      //      il2 =>
      //      {
      //         // Int32 i = 0
      //         var idxB = il.DeclareLocal( LB_INDEX.Type.NewWrapper( this.ctx ) );
      //         il2
      //            .EmitLoadInt32( 0 )
      //            .EmitStoreLocal( idxB );
      //         return idxB;
      //      },
      //      ( il2, idxB, loopBodyStartLabel ) =>
      //      {
      //         // index < evtsToAdd.Length
      //         il2
      //            .EmitLoadLocal( idxB )
      //            .EmitLoadLocal( evtsToAddB )
      //            .EmitLoadArrayLength()
      //            .EmitNumericConversion( CILTypeCode.UInt32, CILTypeCode.Int32, false )
      //            .EmitBranch( BranchType.IF_FIRST_LESSER_THAN_SECOND, loopBodyStartLabel );
      //      },
      //      E_MethodIL.EmitLeftPlusPlus,
      //      ( il2, idxB ) =>
      //      {
      //         il2.EmitLoadLocal( evtsToAddB )
      //            .EmitLoadLocal( idxB )
      //            .EmitLoadLocal( invocationsB )
      //            .EmitLoadLocal( idxB )
      //            .EmitLoadElement( invocationsB.LocalType )
      //            .EmitNewObject( EVENT_INFO_CTOR )
      //            .EmitStoreElement( evtsToAddB.LocalType );
      //      }
      //      )
      //      .EmitInterlockedCompareExchangeFieldSettingLoop(
      //      eventField,
      //      //fieldType,
      //      ( il2, currentB ) =>
      //      {
      //         il2
      //            .EmitLoadLocal( currentB )
      //            .EmitCall( WEAK_EVENT_ARRAY_CLEANUP_METHOD );
      //      },
      //      ( il2, oldCurrentB ) =>
      //      {
      //         il2
      //            .EmitLoadLocal( oldCurrentB )
      //           .EmitLoadLocal( evtsToAddB )
      //           .EmitCall( WEAK_EVENT_ARRAY_COMBINE_METHOD );
      //      }
      //      );
      //   il.EmitReturn();
      //}

      //protected void EmitEventRemovingMethodForWeaklyReferencedEvents(
      //   CILField eventField,
      //   MethodIL il
      //   )
      //{
      //   //Delegate[] invocations = other.GetInvocationList();
      //   //EventHandlerInfoArrayWrapper current = this._myEventManualWeak;
      //   //EventHandlerInfoArrayWrapper oldCurrent, combined;
      //   //do
      //   //{
      //   //   oldCurrent = EventHandlerInfoArrayWrapper.CleanUp( current );
      //   //   combined = EventHandlerInfoArrayWrapper.Remove( oldCurrent, invocations );
      //   //   current = Interlocked.CompareExchange( ref this._myEventManualWeak, combined, oldCurrent );
      //   //} while ( !Object.ReferenceEquals( current, oldCurrent ) );

      //   var invocationsB = il.DeclareLocal( GET_INVOCATION_LIST_METHOD.GetReturnType() );
      //   il
      //      .EmitLoadArg( 1 )
      //      .EmitCall( GET_INVOCATION_LIST_METHOD )
      //      .EmitStoreLocal( invocationsB )

      //      .EmitInterlockedCompareExchangeFieldSettingLoop(
      //      eventField,
      //      ( il2, currentB ) =>
      //      {
      //         il2
      //            .EmitLoadLocal( currentB )
      //            .EmitCall( WEAK_EVENT_ARRAY_CLEANUP_METHOD );
      //      },
      //      ( il2, oldCurrentB ) =>
      //      {
      //         il2
      //            .EmitLoadLocal( oldCurrentB )
      //            .EmitLoadLocal( invocationsB )
      //            .EmitCall( WEAK_EVENT_ARRAY_REMOVE_METHOD );
      //      }
      //      )
      //      .EmitReturn();
      //}

      protected void GetEventInvocationStyle( EventModel eventModel, out EventInvocation invocationStyle, out Type exceptionType )
      {
         EventInvocationStyleAttribute attr = eventModel.AllAttributes.OfType<EventInvocationStyleAttribute>().FirstOrDefault();
         if ( attr == null )
         {
            invocationStyle = EventInvocationStyleAttribute.DEFAULT_INVOCATION_STYLE;
            exceptionType = null;
         }
         else
         {
            invocationStyle = attr.InvocationStyle;
            exceptionType = attr.RethrowException;
         }
      }
   }
}
#endif