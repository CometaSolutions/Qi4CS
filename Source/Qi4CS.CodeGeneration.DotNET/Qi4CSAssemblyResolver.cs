/*
 * Copyright 2013 Stanislav Muhametsin. All rights Reserved.
 *
 * Licensed  under the  Apache License,  Version 2.0  (the "License");
 * you may not use  this file  except in  compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed  under the  License is distributed on an "AS IS" BASIS,
 * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or
 * implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 */
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using Qi4CS.Core.API.Model;

namespace Qi4CS.CodeGeneration
{
   /// <summary>
   /// This is utility class to load all assemblies generated by Qi4CS from a certain directory.
   /// It should use used during invocation of <see cref="Qi4CS.Core.SPI.Model.ApplicationModel{T}.NewInstance(String, String, String)"/> method.
   /// </summary>
   /// <remarks>
   /// It is preferred to use the <c>&lt;probing&gt;</c> element of configuration file to load Qi4CS assemblies from a subpath.
   /// See <see href="http://msdn.microsoft.com/en-us/library/823z9h8w.aspx">MSDN documentation</see> for more information.
   /// However, if using configuration files is not possible or assemblies are not within subdirectory of application base, this class is provided in order to easily load Qi4CS assemblies from certain path.
   /// </remarks>
   /// <example>
   /// <para>
   /// Let's say one has all Qi4CS assemblies in a subdirectory <c>Qi4CS\&lt;ApplicationName&gt;</c>.
   /// The following code snippet demonstrates how to use <see cref="Qi4CSAssemblyResolver"/> in such situation.
   /// <code source="..\Qi4CS.Samples\Qi4CSDocumentation\CILManipulatorCodeContent.cs" region="DotNetReflectionContextCode1" language="C#" />
   /// </para>
   /// <para>
   /// Assuming the Qi4CS assemblies are not in the current directory, without the usage of <see cref="Qi4CSAssemblyResolver"/> when invoking <see cref="Qi4CS.Core.SPI.Model.ApplicationModel{T}.NewInstance(String, String, String)"/>, there would be errors as Qi4CS runtime uses <see cref="System.Reflection.Assembly.Load(String)"/> method to load assemblies.
   /// Because <see cref="Qi4CSAssemblyResolver"/> uses .NET event handlers to handle assembly load, it implements <see cref="IDisposable"/>, and the <see cref="Qi4CSAssemblyResolver.Dispose"/> method handles event unregistration (since all assemblies will be loaded during <see cref="Qi4CS.Core.SPI.Model.ApplicationModel{T}.NewInstance(String, String, String)"/> method, the is no longer need for the event handler the <see cref="Qi4CSAssemblyResolver"/> uses).
   /// </para>
   /// </example>
   public sealed class Qi4CSAssemblyResolver : IDisposable
   {
      private readonly String[] _paths;

      /// <summary>
      /// Creates new instance of <see cref="Qi4CSAssemblyResolver"/> which will load assemblies from given path.
      /// </summary>
      /// <param name="paths">
      /// The paths where Qi4CS generated assemblies are possibly located.
      /// If it is <c>null</c> or empty array, then a single path of <see cref="Environment.CurrentDirectory"/> is used.
      /// Any <c>null</c> elements within the array are ignored.
      /// </param>
      public Qi4CSAssemblyResolver( params String[] paths )
      {
         if ( paths != null )
         {
            paths = paths
               .Where( p => p != null )
               .ToArray();
         }

         if ( paths == null || paths.Length == 0 )
         {
            paths = new String[] { Environment.CurrentDirectory };
         }
         this._paths = paths
            .Select( p => "file:///" + Path.GetFullPath( p ).Replace( '\\', '/' ) )
            .ToArray();

         AppDomain.CurrentDomain.AssemblyResolve += CurrentDomain_AssemblyResolve;
      }

      private System.Reflection.Assembly CurrentDomain_AssemblyResolve( object sender, ResolveEventArgs args )
      {
         var actualName = new String( args.Name.TakeWhile( ch => ch != ',' ).ToArray() );
         return actualName.EndsWith( Qi4CSGeneratedAssemblyAttribute.ASSEMBLY_NAME_SUFFIX ) ?
            this._paths.Select( p =>
            {
               try
               {
                  return System.Reflection.Assembly.LoadFrom( p + "/" + actualName + ".dll" );
               }
               catch
               {
                  return null;
               }
            } ).FirstOrDefault() :
            null;
      }


      #region IDisposable Members

      /// <summary>
      /// Removes the event handler from <see cref="AppDomain.AssemblyResolve"/> event.
      /// </summary>
      public void Dispose()
      {
         AppDomain.CurrentDomain.AssemblyResolve -= this.CurrentDomain_AssemblyResolve;
      }

      #endregion
   }
}
